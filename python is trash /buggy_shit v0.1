import re
import tkinter as tk
from idlelib.configdialog import is_int

root = tk.Tk()
root.title("Mega dummy visualization")

canvas_size = 400
canvas = tk.Canvas(root, width=canvas_size, height=canvas_size)
canvas.pack()

matrix = [ ["un",0,0,"un"],
            [0,0,0,0],
            [0,0,0,0],
            ["un",0,0,0] ]


def shortest_way(p1,p2,mat):
    waves = [[]]
    waves[0].append(p1)
    possible_cells = 1
    waves_num = 0
    while possible_cells != 0:
        waves.append([])

        for i in range(len(waves[-2])):
            waves_all = []


            for j in waves:
                for k in j:
                    waves_all.append(k)


            if mat[waves[-2][i][0]][waves[-2][i][1]] == 0:

                if waves[-2][i][0]+1 < len(mat) and mat[waves[-2][i][0]+1][waves[-2][i][1]] == 0 and (waves[-2][i][0]+1,waves[-2][i][1]) not in waves_all :
                    waves[-1].append((waves[-2][i][0]+1,waves[-2][i][1]))

                if mat[waves[-2][i][0]-1][waves[-2][i][1]] == 0 and (waves[-2][i][0]-1,waves[-2][i][1]) not in waves_all and waves[-2][i][0]-1 > -1:
                    waves[-1].append((waves[-2][i][0]-1,waves[-2][i][1]))

                if mat[waves[-2][i][0]][waves[-2][i][1]-1] == 0 and (waves[-2][i][0],waves[-2][i][1]-1) not in waves_all and  waves[-2][i][1] - 1 > -1:
                    waves[-1].append((waves[-2][i][0],waves[-2][i][1]-1))

                if waves[-2][i][1]+1 < len(mat) and mat[waves[-2][i][0]][waves[-2][i][1]+1] == 0 and (waves[-2][i][0],waves[-2][i][1]+1) not in waves_all:
                    waves[-1].append((waves[-2][i][0],waves[-2][i][1]+1))

        if len(waves[-1]) == 0:
            possible_cells = 0
            waves.pop(-1)

            for l in range(len(waves)):
                for u in range(len(waves[l])):
                    mat[waves[l][u][1]][waves[l][u][0]] = l
            print("step one done")
            return(mat)
def print_matrix(matrix):
    column_widths = [0] * len(matrix[0])

    for row in matrix:
        for idx, element in enumerate(row):
            column_widths[idx] = max(column_widths[idx], len(str(element)))

    # Выводим матрицу с выравниванием
    for row in matrix:
        formatted_row = " ".join(f"{str(element):<{column_widths[idx]}}" for idx, element in enumerate(row))
        print(formatted_row)
def visualization(out_mat):
    square_size = canvas_size // 8
    for i in range(8):  #delaem joskiy windowing
        for j in range(8):
            number = i * 8 + j
            create_square(canvas, j * square_size, i * square_size, square_size, number, i, j,out_mat)

    root.mainloop()
def scale_value(value, from_min, from_max, to_min, to_max):

    normalized_value = (value - from_min) / (from_max - from_min) #поч в питоне нету мапа(((

    scaled_value = to_min + normalized_value * (to_max - to_min)

    return scaled_value
def max_val_mat(mat):
    max = 0 #да, это очень тупая функция но мне пофиг
    for i in range(len(mat)):
        for j in range(len(mat[i])):
            if is_int(mat[i][j]) and  mat[i][j] > max:
                max = mat[i][j]
    return max
def interpolate_color(t):
    light_blue = (75, 120, 230)
    bright_red = (255, 0, 0)

    red = int(light_blue[0] + (bright_red[0] - light_blue[0]) * t)
    green = int(light_blue[1] + (bright_red[1] - light_blue[1]) * t)
    blue = int(light_blue[2] + (bright_red[2] - light_blue[2]) * t)

    return f'#{red:02x}{green:02x}{blue:02x}'
def create_square(canvas, x, y, size, number,i,j,mat):
    #конечно же я не украл этот код (украл)
  if i < len(mat) and j < len(mat[0]):
    if is_int(mat[i][j]):
        color = interpolate_color(scale_value(mat[i][j]+0.01,0.01,max_val_mat(mat),0.1,1))
    else:
        color = "black"
    canvas.create_rectangle(x, y, x + size, y + size, fill=color, outline='')
    canvas.create_text(x + size / 2, y + size / 2, text=str(mat[i][j]), fill='white', font=('Arial', 16, 'bold'))


print_matrix(shortest_way((1,1),(2,2),matrix))
visualization(shortest_way((1,1),(0,0),matrix))

